use anyhow::{Context, Result};
use std::path::PathBuf;
use tokio::sync::mpsc::UnboundedReceiver;
use tycode_core::{
    agents::tool_type::ToolType,
    chat::{ChatActor, ChatEvent, MessageSender},
    formatter::{CompactFormatter, EventFormatter},
};

use crate::github;

pub async fn run_auto_pr(
    issue_number: u32,
    workspace_roots: Vec<PathBuf>,
    profile: Option<String>,
) -> Result<()> {
    let mut formatter = CompactFormatter::new();

    formatter.print_system("Starting auto-PR mode...");

    let issue = github::fetch_issue(issue_number)
        .context("Failed to fetch GitHub issue - ensure gh CLI is installed and authenticated")?;

    formatter.print_system(&format!("Fetched issue #{}: {}", issue.number, issue.title));

    github::ensure_clean_working_tree().context("Cannot proceed with uncommitted changes")?;

    let branch_name = github::create_branch(issue_number).context("Failed to create branch")?;

    formatter.print_system(&format!("Created branch: {}", branch_name));

    let settings_path = dirs::home_dir()
        .context("Failed to get home directory")?
        .join(".tycode")
        .join("settings.toml");

    let (mut actor, mut event_rx) = ChatActor::builder()
        .workspace_roots(workspace_roots)
        .settings_path(settings_path)
        .profile_name(profile)
        .agent_name("auto_pr".to_string())
        .build()?;

    let initial_message = format!(
        "Please help me resolve this GitHub issue:\n\n# {}\n\n{}",
        issue.title, issue.body
    );

    actor.send_message(initial_message)?;

    let drive_result =
        drive_auto_pr_conversation(&mut actor, &mut event_rx, &mut formatter, 100).await;

    match drive_result {
        Ok(summary) => {
            formatter.print_system("Agent completed the task successfully");
            formatter.print_system("Requesting commit message from agent...");

            let commit_message = request_commit_message(&mut actor, &mut event_rx, &mut formatter)
                .await
                .context("Failed to generate commit message")?;

            if commit_message.to_lowercase().contains("claude") {
                return Err(anyhow::anyhow!(
                    "Generated commit message contains 'claude', which is not allowed"
                ));
            }

            github::commit_changes(&commit_message).context("Failed to commit changes")?;

            formatter.print_system("Changes committed");

            github::push_branch().context("Failed to push branch")?;

            formatter.print_system("Branch pushed to remote");

            let pr_body = format!(
                "{}\n\nFixes #{}\n\nAutomatically generated by tycode-cli --auto-pr",
                summary, issue.number
            );

            let pr_url = github::create_pr(issue.number, &issue.title, &pr_body)
                .context("Failed to create pull request")?;

            formatter.print_system(&format!("Pull request created: {}", pr_url));
            println!("\nSuccessfully created PR: {}", pr_url);

            Ok(())
        }
        Err(e) => {
            formatter.print_error(&format!(
                "Auto-PR failed: {}. Branch '{}' has been left for manual inspection.",
                e, branch_name
            ));
            Err(e)
        }
    }
}

async fn drive_auto_pr_conversation(
    actor: &mut ChatActor,
    event_rx: &mut UnboundedReceiver<ChatEvent>,
    formatter: &mut dyn EventFormatter,
    max_messages: usize,
) -> Result<String> {
    let mut requests = 1;
    let mut message_count = 0;
    let mut build_test_success = false;
    let mut summary = String::new();

    while let Some(event) = event_rx.recv().await {
        match event {
            ChatEvent::TypingStatusChanged(typing) => {
                if !typing {
                    requests -= 1;
                    if requests == 0 {
                        if build_test_success {
                            return Ok(summary);
                        }
                        requests += 1;
                        formatter.print_system("Sending reminder message");
                        actor.send_message(
                            "Continue working on the task. When the build and tests pass, use the complete_task tool.".to_string(),
                        )?;
                    }
                }
            }
            ChatEvent::Error(msg) => {
                formatter.print_error(&msg);
                return Err(anyhow::anyhow!("Chat error: {}", msg));
            }
            ChatEvent::MessageAdded(chat_message) => {
                if let MessageSender::Assistant { .. } = chat_message.sender {
                    message_count += 1;
                    if message_count > max_messages {
                        return Err(anyhow::anyhow!(
                            "Exceeded maximum of {} messages",
                            max_messages
                        ));
                    }
                }
                handle_message_added(chat_message, formatter);
            }
            ChatEvent::ToolRequest(tool_request) => {
                formatter.print_tool_request(&tool_request);

                if tool_request.tool_name == ToolType::CompleteTask.name() {
                    if let tycode_core::chat::events::ToolRequestType::Other { args } =
                        &tool_request.tool_type
                    {
                        if let Some(result_str) = args.get("result") {
                            if let Some(result) = result_str.as_str() {
                                summary = result.to_string();
                            }
                        }
                    }
                }

                if tool_request.tool_name == ToolType::AskUserQuestion.name() {
                    requests += 1;
                    actor.send_message(
                        "You are running in automated mode and cannot ask questions. Please make reasonable decisions and continue.".to_string(),
                    )?;
                }
            }
            ChatEvent::ToolExecutionCompleted {
                tool_name,
                success,
                tool_result,
                ..
            } => {
                formatter.print_tool_result(&tool_name, success, tool_result, false);

                if tool_name == ToolType::RunBuildTestCommand.name() && success {
                    build_test_success = true;
                    formatter.print_system("Build and tests passed!");
                }

                if tool_name == ToolType::CompleteTask.name() && success {
                    if build_test_success {
                        return Ok(summary);
                    }
                    return Err(anyhow::anyhow!(
                        "Task marked complete but build/tests did not pass"
                    ));
                }
            }
            ChatEvent::RetryAttempt {
                attempt,
                max_retries,
                error,
                backoff_ms,
            } => {
                formatter.print_system(&format!(
                    "Retry {attempt}/{max_retries}: {error}, backoff {backoff_ms}ms"
                ));
            }
            _ => (),
        }
    }

    Err(anyhow::anyhow!("Event stream ended unexpectedly"))
}

fn handle_message_added(
    chat_message: tycode_core::chat::ChatMessage,
    formatter: &mut dyn EventFormatter,
) {
    match chat_message.sender {
        MessageSender::Assistant { agent } => {
            if let Some(reasoning) = &chat_message.reasoning {
                formatter.print_system(&format!("Reasoning: {reasoning}"));
            }

            formatter.print_ai(
                &chat_message.content,
                &agent,
                &chat_message.model_info,
                &chat_message.token_usage,
            );

            if !chat_message.tool_calls.is_empty() {
                let count = chat_message.tool_calls.len();
                let call_text = if count == 1 { "call" } else { "calls" };
                let names = chat_message
                    .tool_calls
                    .iter()
                    .map(|tc| tc.name.as_str())
                    .collect::<Vec<&str>>()
                    .join(", ");
                formatter.print_system(&format!("Tool {call_text}: {names}"));
            }
        }
        MessageSender::System => formatter.print_system(&chat_message.content),
        MessageSender::Warning => formatter.print_system(&chat_message.content),
        MessageSender::Error => formatter.print_error(&chat_message.content),
        MessageSender::User => formatter.print_system(&chat_message.content),
    }
}

async fn request_commit_message(
    actor: &mut ChatActor,
    event_rx: &mut UnboundedReceiver<ChatEvent>,
    formatter: &mut dyn EventFormatter,
) -> Result<String> {
    let prompt = "Generate a concise conventional commit message for the changes you made. \
                  Use the format: <type>: <description>. \
                  Do not include your name or the word 'Claude' in the message. \
                  Keep it under 72 characters for the first line.";

    actor.send_message(prompt.to_string())?;

    while let Some(event) = event_rx.recv().await {
        match event {
            ChatEvent::MessageAdded(chat_message) => {
                if let MessageSender::Assistant { .. } = chat_message.sender {
                    let commit_msg = chat_message.content.trim().to_string();
                    if !commit_msg.is_empty() {
                        formatter
                            .print_system(&format!("Generated commit message: {}", commit_msg));
                        return Ok(commit_msg);
                    }
                }
            }
            ChatEvent::Error(msg) => {
                return Err(anyhow::anyhow!(
                    "Error while generating commit message: {}",
                    msg
                ));
            }
            _ => {}
        }
    }

    Err(anyhow::anyhow!(
        "Event stream ended before receiving commit message"
    ))
}
